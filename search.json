[{"title":"python正则表达式","url":"/2018/08/29/python_re/","content":"\n### compile函数\ncompile函数将一个pattern编译成正则对象，以便后面多次匹配\n```python\nre.compile(pattern, flag)\n```\n\n### match函数\nmatch函数决定Re是否存在字符串开始的位置匹配（不是完全匹配，如果想要完全匹配，需要在表达式末尾加上边界匹配符$)\n```python\nre.match(pattern, string, flag)\n```\n例如：\n```python\nrlt = re.match('com', 'comwww.run').group()\nprint rlt\t#输出为com\n```\n\n### search函数\nsearch函数在字符串中查找模式匹配，只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None\n```python\nre.search(pattern, string, flag)\n```\n例如：\n```python\nrlt = re.search(r'\\dcom', 'www.4comrunoob.5com').group()\nprint rlt\t#输出为4com\n```\n\n注意：match 和 search 函数返回的是一个match object 对象，match object对象有group()、start()、end()、 span()、groups()等函数\n```python\na = \"123abc456\"\nprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(0))   #123abc456,返回整体\nprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(1))   #123\nprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(2))   #abc\nprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(3))   #456\nprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).groups())   #('123','abc','456')\n```\n\n### findall函数\nfindall函数遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表\n```python\nre.finall(pattern, string ,flag)\n```\n如果pattern中有分组，则返回一个列表，列表中的元素是元组，元组的两个元素分别是匹配分组的开头和结尾。例如：\n```python\ntt = 'tina is a good girl, she is cool, clever, and so on...'\nre1 = re.compile(r'\\w*oo\\w*')\nprint(re1.findall(tt))     #['good','cool']\n\nre2 = re.compile(r'(\\w)*oo(\\w)*')\nprint(re2.findall(tt))     #[('g','d'),('c','l')]\n```\n\n注意：match/search和findall函数的区别：\n```python\nre.match('<.*?>','<H1>title<H1>').group()   #<H1>\nre.search('<.*?>','<H1>title<H1>').group()  #<H1>\nre.findall('<.*?>','<H1>title<H1>')         #['H1','H1']\n```\nfindall函数没有返回'<'和'>'\n\n\n### finditer函数\nre.finditer函数，返回一个顺序访问每一个匹配结果（match object)的迭代器\n```python\nre.finditer(pattern, string, flag)\n```\n例如：\n```python\niter = re.finditer('\\d+', '12abc34de56')\nfor i in iter:\n  print(i)\n  print(i.group())\n  print(i.span())\n```\n输出结果：\n```python\n<_sre.SRE_Match object；span=(0,2), match='12'>\n12\n(0,2)\n<_sre.SRE_Match object；span=(5,7), match='34'>\n34\n(5,7)\n<_sre.SRE_Match object；span=(9,11), match='56'>\n56\n(9,11)\n```\n\n### split函数\nsplit函数按照能够匹配的子串将string分割后返回列表。\n```python\nre.split(pattern, string[, maxsplit])\n```\nmaxsplit是最大分割次数，默认为全部分割。例如：\n```python\nprint(re.split('\\d+', 'one1two2three3four4five5'))\t#输出['one','two','three','four','five','']\n```\n\n### sub函数\nsub函数使用repl替换string中每一个匹配的子串，然后返回替换后的字符串\n```python\nre.sub(pattern, repl, string, count)\n```\ncount是指替换个数，默认为0,表示每个匹配项都替换。例如\n```python\ntext='JGood is a handsome boy, he is cool, clever, and so on...'\nprint(re.sub(r'\\s+','-', text))\t#JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...\n```\n输出结果为将text中的空格替换成-\n```python\nprint(re.sub(r'\\s', lambda m:'['+m.group(0)+']', text, 0))\t#JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on...\n```\n输出结果为将字符串中的空格替换成'[ ]'\n\n\n### subn函数\nsubn函数以元组的形式返回替换后的字符串和替换次数\n```python\nre.subn(pattern, repl, string, count=0, flags=0)\n```\n例如：\n```python\nprint(re.subn(\"g.t\", \"have\", \"I get A, I got B, I gut C\"))\t#('I have A, I have B, I have C', 3)\n```\n\n### 非贪婪匹配?\n用?来区分贪婪匹配和非贪婪匹配，贪婪匹配即在满足条件情况下尽可能多的匹配。例如：\n```python\nre.match('<.*>','<H1>title<H1>').group()\t#<H1>title<H1>\nre.match('<.*?>','<H1>title<H1>').group()\t#<H1>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["python"]},{"title":"sublime text3 使用virtualenv","url":"/2018/08/29/sublime-virtualenv/","content":"1. 安装virtualenv插件。ctrl+shift+P打开万能面板，输入install，在出现的选项中选择Package Control:install package，稍等一下，待弹出提示框后输入virtualenv，选中它，然后回车即可安装，安装完之后会出现一个新窗口package control message，有virtualenv简介。\n\n2. 新建/添加python虚拟环境。（如果你已经有虚拟环境，跳过这一步，直接进入下一步配置）ctrl+shitf+p，输入virtualenv:new，选择出现的该选项，在sublime底部virtualenv path栏输入你要新建虚拟环境的路径，例如C:\\code\\project_name\\venv\\，一般建议在项目目录下新建一个文件夹venv，用于新建虚拟环境。然后等待安装完成。\n\n3. 配置sublimeREPL，preferences->package settings->sublimeREPL->Settings-user，然后添加以下内容：\n```python\n{\n\t\"default_extend_env\": {\"PATH\":\"C:\\\\code\\\\project_name\\\\venv\\\\Scripts\"},\n}\n```\n这个将sublimeREPL的运行默认设置为你的虚拟环境，运行当前python文件的快捷键F1和开启交互式ipython窗口的快捷键F2也会使用你的虚拟环境，快捷键根据你自己的设置可能与我的不同。如果想以非虚拟环境运行当前python文件，使用ctrl+b。ctrl + b方式运行python文件不支持键盘输入，sublimeREPL方式运 行（F1快捷键）可以输入数据。\n\n快捷键的配置在preferences->key Binding->user，我的配置文件如下：\n```python\n[\n{\"keys\":[\"f1\"],\n\"caption\": \"SublimeREPL: Python - RUN current file\",\n\"command\": \"run_existing_window_command\", \"args\":\n{\"id\": \"repl_python_run\",\"file\": \"config/Python/Main.sublime-menu\"}\n},\n{\"keys\":[\"f2\"],\n\"caption\": \"SublimeREPL: Python - IPython\",\n\"command\": \"run_existing_window_command\", \"args\":\n{\"id\": \"repl_python_ipython\",\"file\": \"config/Python/Main.sublime-menu\"}\n}\n]\n```\n以上配置使用F1运行当前python文件，F2进入交互式ipython。\n\n\nPS: 目前发现，在配置文件sublimeREPL->Setting-user中添加了“default_extend_env”之后，就在sublimeREPL中使用非虚拟环境的F1和F2了，如果想要以非虚拟环境运行当前python文件，或者需要以非虚拟环境进入ipython交互模型，需要将配置文件中的哪一行注释掉：\n```python\n{\n\t//\"default_extend_env\": {\"PATH\":\"C:\\\\code\\\\project_name\\\\venv\\\\Scripts\"},\n}\n```\n感觉这样很麻烦，但目前仍未找到更好的解决办法，尝试过更改Tool->Build System->Python或Python+virtualenv，无效，决定F1和F2环境的还是配置文件。也尝试过在万能面板（ctrl+shift+p）中激活虚拟环境virtualenv:activate和关闭虚拟环境virtualenv:Deactivate，无效，决定F1和F2环境的还是配置文件。","tags":["工具"]},{"title":"CRF Notes","url":"/2018/08/25/CRF-notes/","content":"内容涉及CRF的基本介绍，CRF与HMM的区别，以及CRF用于分词。\n\n## 预备知识\n### 概率图模型\n概率图模型是指用无向图$G(V,E)$表示的概率分布。图中的每个点$v$表示一个随机变量，点之间的边$e$表示随机变量之间的概率依赖关系，整个图则表示这一组随机变量的联合概率分布$P(Y)$。\n\n![](/images/undirected_graph.jpg)\n\n上图中7个点构成一组随机变量，有直连边的两个随机变量相互依赖。\n\n### 概率无向图模型\n概率无向图模型(probabilistic undirected graphical model)，也称为马尔可夫随机场（Markov random field)。如果一个由概率图模型$G(V,E)$表示的联合概率分布$P(Y)$，满足成对、局部或全局马尔可夫性，则$P(Y)$就称为概率无向图模型，或者马尔可夫随机场。\n\n* 成对马尔可夫性\n\n没有直连边的两个随机变量是条件独立的。例如上图中，点1和点5对应的随机变量$Y_1$和$Y_5$之间没有直连边，则它们是条件独立的，用公式表示就是\n\n$$P(Y_1,Y_5|Y_o)=P(Y_1|Y_o)P(Y_5|Y_o)$$\n\n其中$Y_o$表示除了点1和点5，其他点对应的随机变量组\n\n* 局部马尔可夫性\n\n局部马尔可夫性将形式扩展到随机变量与随机变量组之间的关系，与某个随机变量没有直连边的随机变量组与该随机变量是条件独立的。例如上图中，在给定随机变量组$Y_w$的条件下随机变量$Y_3$与随机变量$Y_o$是条件独立的，其中$Y_w$是与点3有直连边的点对应的随机变量组，即$(Y_2,Y_4)$，$Y_o$是其他的点对应的随机变量组，即$(Y_1,Y_5,Y_6,Y_7)$，用公式表示就是\n\n$$P(Y_3,Y_o|Y_w)=P(Y_3|Y_w)P(Y_o|Y_w)$$\n\n* 全局马尔可夫性\n\n全局马尔可夫性将性质扩展到随机变量组之间的关系，即两个没有直连边的随机变量组之间也是条件独立的。例如在上图中，结点结合$A=(1,6)$，结点集合$B=(5,7)$，这两个集合中的点不存在直连边，则它们对应的随机变量组是条件独立的：\n$$P(Y_A,Y_B|Y_C)=P(Y_A|Y_C)P(Y_B|Y_C)$$\n其中$Y_C$是除了集合$A$和集合$B$中的结点外其他结点对应的随机变量组，在本例中，$C=(2,3,4)$\n\n以上三种性质是等价的，因此只要联合概率分布P(Y)满足一个性质，就是概率无向图模型，即马尔可夫随机场。\n\n### 图的团和最大团\n在无向图$G$中，任何两个结点均有边连接的结点子集称为团(clique)。如果$C$是无向图$G$的一个团，并且不能再加进任何一个$G$的结点使其称为一个更大的团，则称此$C$为最大团(maximal clique)\n\n### 概率无向图模型的因子分解\n概率无向图模型的联合概率分布$P(Y)$可以表示为图中所有最大团上的函数的乘积形式，这个过程称为概率无向图模型的因子分解(factorization)\n\n$$P(Y)=\\frac 1 Z \\prod_C f_C(Y_C)$$\n\n其中，$Z$是规范化因子\n$$Z=\\sum_Y \\prod_C f_C(Y_C)$$\n\n\n## CRF介绍\n条件随机场(CRF)是给定一组输入随机变量O条件下，另一组输出随机变量S的条件概率分布模型，其特点是假设输出随机变量S构成马尔可夫随机场。为了和隐式马尔可夫模型(HMM)对比，可以认为输入随机变量O即观测状态，输出随机变量S即隐藏状态（在用水藻状态预测天气例子中，水藻状态即观测状态，天气状态即隐藏状态）。\n\n线性链条件随机场一般用于序列标注问题，我们以下讨论的均为线性链条件随机场的使用。\n![](/images/chain_crf.png)\n\n在标注序列中，$O$表示输入观测状态序列，$S$表示对应的输出隐藏状态序列（即标注序列）。从图中我们可以看出，线性链条件随机场中，最大团是每两个相邻的结点。故其联合概率分布可以表示成相邻两个结点上的函数。\n![](/images/p_yx.jpg)\n\n其中\n\n![](/images/z.jpg)\n\n$t_k$和$s_l$为特征函数，$t_k$是定义在边上的函数，称为转移特征，$s_l$是定义在结点上的特征，称为状态特征。$\\lambda_k$和$u_l$为对应的权重。\n\n这里的输出序列$y$即为我们说的隐藏状态序列$S$，输入序列$x$即为观测序列$O$。\n\n## 线性链CRF与HMM模型的区别\n首先，HMM有两个假设：\n\n* 齐次马尔可夫性假设：隐藏的马尔可夫链在任意时刻$t$的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻$t$无关\n\n* 观测独立性假设：任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关\n\n而线性链CRF没有这么强的假设，从它的因子分解式的边函数$t\\_k$可以发现，在线性链CRF中，某时刻$t$的隐藏状态$S\\_t$依赖于前一时刻的隐藏状态$S\\_{t-1}$，还依赖于上下文$O$，即整个观测序列。一般在实际应用中不会考虑整个观测序列，而是使用前后一个窗口范围内的观测状态，例如$O\\_{t-2},O\\_{t-1},O\\_{t+1},O\\_{t+2}$。\n线性链CRF对于观测状态没有进行假设，从因子分解式的点函数$s\\_l$中可以看出，在$t$时刻的观测状态$O\\_t$依赖于该时刻的隐藏状态$S\\_t$，也同样依赖于上下文$O$。\n\n\n## CRF分词过程\n线性链CRF常用于序列标注问题，给定输入序列，预测输出标注序列。以分词为例，CRF分词是一种组字成词的方法，输入序列为句子中的每个字组成的序列，输出则是各个字对应的标签，标签集合为BMES，B表示词语的开头，M表示词语中间，E表示词语结尾，S表示单字成词。根据字对应的标签，就可以完成分词了。\n\nCRF的特征函数（包括边函数和点函数）需要通过特征模板来定义。在HanLP工具中，其CRF模型是采用了C++实现的开源工具CRF++。HanLP中定义的特征模板如下：\n\n```python\n#unigram\nU00:%x[-2,0]\nU01:%x[-1,0]\nU02:%x[0,0]\nU03:%x[1,0]\nU04:%x[2,0]\nU05:%x[-2,0]/%x[-1,0]/%x[0,0]\nU06:%x[-1,0]/%x[0,0]/%x[1,0]\nU07:%x[0,0]/%x[1,0]/%x[2,0]\nU08:%x[-1,0]/%x[0,0]\nU09:%x[0,0]/%x[1,0]\n\n#bigram\nB\n```\n其中，unigram表示点函数$f(s_t,o)$的模板。U表示是Unigram的特征，00表示特征编号，%x是模板待填充的上下文$o$，[#1,#2]中#1表示相对与当前位置的行偏移，#2表示相对于当前位置的列偏移（由于训练语料中考虑的上下文都在第0列，所以相对列偏移为0）。\n\nbigram表示边函数$f(s\\_{t-1},s\\_t,o)$，这里简单的B表示不考虑上下文，只考虑隐藏状态的转移，即$f(s\\_{t-1},s\\_t)$，同HMM中的状态转移矩阵一样。\n\n假如我们现在有一个包含两句已经分好词的训练数据：\n```python\n我 去 北京大学 玩\n我国 的 首都 是 北京\n```\n通过BMES标注处理之后，训练数据如下：\n\n```python\n我\tS\n去\tS\n北\tB\n京\tM\n大\tM\n学\tE\n玩\tS\n我\tB\n国\tE\n的\tS\n首\tB\n都\tE\n是\tS\n北\tB\n京\tE\n```\n以这个模板为例，这个为模板的意思是考虑当前词语前面的第二个字作为上下文，\n```python\nU00:%x[-2,0]\n```\n依次扫描训练语料，扫描到的字即当前位置，假设当前位置是第四个字“京”，根据这个模板，我们会产生下面的特征：\n```python\nB U00:去\nM U00:去\nE U00:去\nS U00:去\n```\n对于模板U00来说，在当前位置，点函数$f(s,o)$=“M U00:去”对应的值为1，其他为0。“M U00:去”中的M是“京”的标签，这里将“去”的标签省略了，“去”的标签有四种可能。\n\n如果是模板U01:%x[-1,0]，当前位置是第三个字“北”，则会产生下面的特征：\n```python\nB U01:去\nM U01:去\nE U01:去\nS U01:去\n```\n虽然考虑的上下文都是“去”，但是由于是不同的模板产生的，也是不同的特征，特征序号就是用以区分它们的。\n所有这些特征都会对应一个特征权重$u_i$，模型训练的参数就是这些特征权重。\n\n模型的训练算法包括：改进的迭代尺度法和拟牛顿法（算法细节可参考李航老师的《统计学习方法》）\n模型训练完成之后，则根据Viterbi算法，计算状态转移最优路径，完成分词，同HMM模型中一样。\n\n\n## Reference\n* 李航《统计学习方法》\n* [CRF++模板格式说明](http://www.hankcs.com/nlp/the-crf-model-format-description.html)\n","tags":["分词"]},{"title":"Hello World","url":"/2018/08/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["hexo"]}]